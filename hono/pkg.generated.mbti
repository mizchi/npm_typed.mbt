// Generated using `moon info`, DON'T EDIT IT
package "mizchi/npm_typed/hono"

import(
  "mizchi/js/core"
  "mizchi/js/web/http"
  "mizchi/npm_typed/better_auth"
)

// Values
pub fn[T] context_provider(HonoContext[T], Array[&HonoNode], value~ : T) -> JSXNode

pub fn cors(origin? : String, allowMethods? : Array[String], allowHeaders? : Array[String], maxAge? : Int, credentials? : Bool, exposeHeaders? : Array[String]) -> CorsMiddleware

pub fn[T] create_context(T?) -> HonoContext[T]

pub fn[Env, ExecutionContext] delete_cookie(Context[Env, ExecutionContext], String, path? : String, secure? : Bool, domain? : String) -> String?

pub fn fragment(Array[&HonoNode], key? : String) -> JSXNode

pub fn[Env, ExecutionContext] get_all_cookies(Context[Env, ExecutionContext]) -> Map[String, String]

pub fn[Env, ExecutionContext] get_cookie(Context[Env, ExecutionContext], String, prefix? : String) -> String?

pub async fn[Env, ExecutionContext] get_signed_cookie(Context[Env, ExecutionContext], String, String) -> String?

pub fn hc(String) -> HonoClient

pub fn html(String) -> HtmlEscapedString

pub async fn import_hono_css() -> HonoCss

pub async fn import_hono_jsx() -> HonoJsx

pub async fn init_jsx_runtime() -> Unit

#alias(h)
pub fn jsx(String, Array[&HonoNode], props? : Map[String, @core.Any], style? : Map[String, String], class? : &CssClassName, id? : String, key? : String) -> JSXNode

pub fn[T] jsx_component((T) -> JSXNode, T, children? : Array[&HonoNode], key? : String) -> JSXNode

pub fn jwt_decode(String) -> JwtDecoded

pub async fn jwt_sign(@core.Any, String, alg? : JwtAlgorithm) -> String

pub async fn jwt_sign_payload(JwtPayload, String, alg? : JwtAlgorithm) -> String

pub async fn jwt_verify(String, String, alg? : JwtAlgorithm) -> @core.Any

pub fn[T] memo((T) -> JSXNode) -> (T) -> JSXNode

pub fn[Env, ExecutionContext] mount_auth(Hono[Env, ExecutionContext], @better_auth.Auth) -> Hono[Env, ExecutionContext]

pub fn raw(String) -> JSXNode

pub fn render_to_readable_stream(JSXNode) -> @core.Any

pub fn render_to_string(JSXNode) -> String

pub fn[Env, ExecutionContext] set_cookie(Context[Env, ExecutionContext], String, String, domain? : String, expires? : @core.Any, httpOnly? : Bool, maxAge? : Int, path? : String, secure? : Bool, sameSite? : String, priority? : String, prefix? : String, partitioned? : Bool) -> Unit

pub async fn[Env, ExecutionContext] set_signed_cookie(Context[Env, ExecutionContext], String, String, String, domain? : String, expires? : @core.Any, httpOnly? : Bool, maxAge? : Int, path? : String, secure? : Bool, sameSite? : String, priority? : String, prefix? : String, partitioned? : Bool) -> Unit

pub fn[Env, ExecutionContext] test_client(Hono[Env, ExecutionContext]) -> HonoClient

pub fn[Env, ExecutionContext] toHonoHandler(@better_auth.Auth) -> async (Context[Env, ExecutionContext]) -> @http.Response

pub fn[T] use_context(HonoContext[T]) -> T

// Errors

// Types and methods
pub type ClientEndpoint
pub fn ClientEndpoint::as_any(Self) -> @core.Any
pub async fn ClientEndpoint::delete_(Self, query? : @core.Any, form? : @core.Any, json? : @core.Any, param? : @core.Any, header? : @core.Any, init? : @core.Any) -> ClientResponse
pub async fn ClientEndpoint::get_(Self, query? : @core.Any, form? : @core.Any, json? : @core.Any, param? : @core.Any, header? : @core.Any, init? : @core.Any) -> ClientResponse
pub async fn ClientEndpoint::patch_(Self, query? : @core.Any, form? : @core.Any, json? : @core.Any, param? : @core.Any, header? : @core.Any, init? : @core.Any) -> ClientResponse
pub async fn ClientEndpoint::post_(Self, query? : @core.Any, form? : @core.Any, json? : @core.Any, param? : @core.Any, header? : @core.Any, init? : @core.Any) -> ClientResponse
pub async fn ClientEndpoint::put_(Self, query? : @core.Any, form? : @core.Any, json? : @core.Any, param? : @core.Any, header? : @core.Any, init? : @core.Any) -> ClientResponse
pub fn ClientEndpoint::url_(Self, query? : @core.Any, form? : @core.Any, json? : @core.Any, param? : @core.Any, header? : @core.Any, init? : @core.Any) -> String

pub type ClientResponse
#alias(array_buffer)
pub async fn ClientResponse::arrayBuffer(Self) -> @core.Any
pub fn ClientResponse::as_any(Self) -> @core.Any
pub async fn ClientResponse::blob(Self) -> @core.Any
pub fn ClientResponse::headers(Self) -> @core.Any
pub async fn ClientResponse::json(Self) -> @core.Any
pub fn ClientResponse::ok(Self) -> Bool
pub fn ClientResponse::status(Self) -> Int
pub async fn ClientResponse::text(Self) -> String

pub(all) struct Context[Env, ExecutionContext] {
  req : HonoRequest
  env : Env
  executionCtx : ExecutionContext
}
pub fn[Env, ExecutionContext] Context::as_any(Self[Env, ExecutionContext]) -> @core.Any
pub fn[Env, ExecutionContext] Context::body(Self[Env, ExecutionContext], String, status? : Int, headers? : @core.Any) -> @http.Response
#alias(execution_ctx)
pub fn[Env, ExecutionContext] Context::executionCtx(Self[Env, ExecutionContext]) -> ExecutionContext
#alias(get_value)
pub fn[Env, ExecutionContext] Context::getValue(Self[Env, ExecutionContext], String) -> @core.Any
pub fn[Env, ExecutionContext] Context::header(Self[Env, ExecutionContext], String, String) -> Unit
pub fn[Env, ExecutionContext] Context::html(Self[Env, ExecutionContext], String, status? : Int) -> @http.Response
pub fn[Env, ExecutionContext] Context::html_jsx(Self[Env, ExecutionContext], JSXNode, status? : Int) -> @http.Response
pub fn[Env, ExecutionContext, T] Context::json(Self[Env, ExecutionContext], T, status? : Int) -> @http.Response
#alias(not_found)
pub fn[Env, ExecutionContext] Context::notFound(Self[Env, ExecutionContext]) -> @http.Response
pub fn[Env, ExecutionContext] Context::redirect(Self[Env, ExecutionContext], String, status? : Int) -> @http.Response
pub fn[Env, ExecutionContext] Context::render(Self[Env, ExecutionContext], String) -> @http.Response
pub fn[Env, ExecutionContext] Context::res(Self[Env, ExecutionContext]) -> @http.Response
pub fn[Env, ExecutionContext] Context::set(Self[Env, ExecutionContext], String, @core.Any) -> Unit
#alias(set_renderer)
pub fn[Env, ExecutionContext] Context::setRenderer(Self[Env, ExecutionContext], (String) -> @http.Response) -> Unit
pub fn[Env, ExecutionContext] Context::status(Self[Env, ExecutionContext], Int) -> Unit
pub async fn[Env, ExecutionContext] Context::stream_jsx(Self[Env, ExecutionContext], HonoJsx, JSXNode, status? : Int) -> @http.Response
pub fn[Env, ExecutionContext] Context::text(Self[Env, ExecutionContext], String, status? : Int) -> @http.Response
pub fn[Env, ExecutionContext] Context::var_(Self[Env, ExecutionContext], String) -> @core.Any

#external
pub type CorsMiddleware
pub fn CorsMiddleware::as_any(Self) -> @core.Any

#external
pub type CssClass
pub fn CssClass::as_any(Self) -> @core.Any
pub fn CssClass::to_string(Self) -> String
pub impl CssClassName for CssClass

#external
pub type Hono[Env, ExecutionContext]
pub fn[Env, ExecutionContext] Hono::all(Self[Env, ExecutionContext], String, async (Context[Env, ExecutionContext]) -> @http.Response) -> Self[Env, ExecutionContext]
pub fn[Env, ExecutionContext] Hono::as_any(Self[Env, ExecutionContext]) -> @core.Any
#alias(base_path)
pub fn[Env, ExecutionContext] Hono::basePath(Self[Env, ExecutionContext], String) -> Self[Env, ExecutionContext]
pub fn[Env, ExecutionContext] Hono::cors(Self[Env, ExecutionContext], String, origin? : String, allowMethods? : Array[String], allowHeaders? : Array[String], maxAge? : Int, credentials? : Bool, exposeHeaders? : Array[String]) -> Self[Env, ExecutionContext]
pub fn[Env, ExecutionContext] Hono::cors_all(Self[Env, ExecutionContext], origin? : String, allowMethods? : Array[String], allowHeaders? : Array[String], maxAge? : Int, credentials? : Bool, exposeHeaders? : Array[String]) -> Self[Env, ExecutionContext]
pub fn[Env, ExecutionContext] Hono::delete(Self[Env, ExecutionContext], String, async (Context[Env, ExecutionContext]) -> @http.Response) -> Self[Env, ExecutionContext]
pub fn[Env, ExecutionContext] Hono::fetch(Self[Env, ExecutionContext], @http.Request) -> @core.Promise[@http.Response]
pub fn[Env, ExecutionContext] Hono::fire(Self[Env, ExecutionContext]) -> Self[Env, ExecutionContext]
pub fn[Env, ExecutionContext] Hono::get(Self[Env, ExecutionContext], String, async (Context[Env, ExecutionContext]) -> @http.Response) -> Self[Env, ExecutionContext]
pub fn[Env, ExecutionContext] Hono::mount(Self[Env, ExecutionContext], String, Self[Env, ExecutionContext]) -> Self[Env, ExecutionContext]
pub async fn[Env, ExecutionContext] Hono::new(strict? : Bool) -> Self[Env, ExecutionContext]
#alias(not_found)
pub fn[Env, ExecutionContext] Hono::notFound(Self[Env, ExecutionContext], async (Context[Env, ExecutionContext]) -> @http.Response) -> Self[Env, ExecutionContext]
#alias(on_error)
pub fn[Env, ExecutionContext] Hono::onError(Self[Env, ExecutionContext], (@core.Any, Context[Env, ExecutionContext]) -> @http.Response) -> Self[Env, ExecutionContext]
pub fn[Env, ExecutionContext] Hono::options(Self[Env, ExecutionContext], String, async (Context[Env, ExecutionContext]) -> @http.Response) -> Self[Env, ExecutionContext]
pub fn[Env, ExecutionContext] Hono::patch(Self[Env, ExecutionContext], String, async (Context[Env, ExecutionContext]) -> @http.Response) -> Self[Env, ExecutionContext]
pub fn[Env, ExecutionContext] Hono::post(Self[Env, ExecutionContext], String, async (Context[Env, ExecutionContext]) -> @http.Response) -> Self[Env, ExecutionContext]
pub fn[Env, ExecutionContext] Hono::put(Self[Env, ExecutionContext], String, async (Context[Env, ExecutionContext]) -> @http.Response) -> Self[Env, ExecutionContext]
pub fn[Env, ExecutionContext] Hono::route(Self[Env, ExecutionContext], String, Self[Env, ExecutionContext]) -> Self[Env, ExecutionContext]
pub fn[Env, ExecutionContext] Hono::use_(Self[Env, ExecutionContext], String, (Context[Env, ExecutionContext], () -> @core.Promise[@http.Response]) -> @core.Promise[@http.Response]) -> Self[Env, ExecutionContext]
pub fn[Env, ExecutionContext] Hono::useall(Self[Env, ExecutionContext], (Context[Env, ExecutionContext], () -> @core.Promise[@http.Response]) -> @core.Promise[@http.Response]) -> Self[Env, ExecutionContext]

pub type HonoClient
pub fn HonoClient::as_any(Self) -> @core.Any
pub fn HonoClient::path(Self, String) -> ClientEndpoint

#external
pub type HonoContext[T]
pub fn[T] HonoContext::as_any(Self[T]) -> @core.Any

#external
pub type HonoCss
pub fn HonoCss::css(Self, String, args? : Array[@core.Any]) -> CssClass
pub fn HonoCss::cx(Self, Array[CssClass]) -> CssClass
pub fn HonoCss::keyframes(Self, String, args? : Array[@core.Any]) -> CssClass
pub fn HonoCss::style_component(Self, nonce? : String) -> JSXNode

#external
pub type HonoJsx
pub fn[T] HonoJsx::context_provider(Self, HonoContext[T], Array[&HonoNode], value~ : T) -> JSXNode
pub fn[T] HonoJsx::create_context(Self, T?) -> HonoContext[T]
pub fn HonoJsx::fragment(Self, Array[&HonoNode], key? : String) -> JSXNode
pub fn HonoJsx::h(Self, String, Array[&HonoNode], props? : Map[String, @core.Any], style? : Map[String, String], class? : &CssClassName, id? : String, key? : String) -> JSXNode
pub fn HonoJsx::html(Self, String) -> HtmlEscapedString
pub fn HonoJsx::jsx(Self, String, Array[&HonoNode], props? : Map[String, @core.Any], style? : Map[String, String], class? : &CssClassName, id? : String, key? : String) -> JSXNode
pub fn[T] HonoJsx::jsx_component(Self, (T) -> JSXNode, T, children? : Array[&HonoNode], key? : String) -> JSXNode
pub fn[T] HonoJsx::memo(Self, (T) -> JSXNode) -> (T) -> JSXNode
pub fn HonoJsx::raw(Self, String) -> JSXNode
pub fn HonoJsx::render_to_readable_stream(Self, JSXNode) -> @core.Any
pub fn[T] HonoJsx::use_context(Self, HonoContext[T]) -> T

pub(all) struct HonoRequest {
  url : String
  bodyUsed : Bool
}
#alias(array_buffer)
pub async fn HonoRequest::arrayBuffer(Self) -> @core.Any
pub fn HonoRequest::as_any(Self) -> @core.Any
pub async fn HonoRequest::blob(Self) -> @core.Any
#alias(form_data)
pub async fn HonoRequest::formData(Self) -> @http.FormData
pub fn HonoRequest::header(Self, String) -> String?
pub async fn HonoRequest::json(Self) -> @core.Any
pub fn HonoRequest::method_(Self) -> String
pub fn HonoRequest::param(Self, String) -> String?
#alias(param_all)
pub fn HonoRequest::paramAll(Self) -> @core.Any
#alias(parse_body)
pub async fn HonoRequest::parseBody(Self, options? : @core.Any) -> @core.Any
pub fn HonoRequest::path(Self) -> String
pub fn HonoRequest::query(Self, String) -> String?
#alias(query_all)
pub fn HonoRequest::queryAll(Self) -> @core.Any
pub async fn HonoRequest::text(Self) -> String

#external
pub type HtmlEscapedString
pub fn HtmlEscapedString::as_any(Self) -> @core.Any
pub impl HonoNode for HtmlEscapedString

#external
pub type JSXNode
pub fn JSXNode::as_any(Self) -> @core.Any
pub impl HonoNode for JSXNode

pub(all) enum JwtAlgorithm {
  HS256
  HS384
  HS512
  RS256
  RS384
  RS512
  PS256
  PS384
  PS512
  ES256
  ES384
  ES512
  EdDSA
}

pub struct JwtDecoded {
  header : @core.Any
  payload : @core.Any
}

pub(all) struct JwtPayload {
  sub : String?
  iss : String?
  aud : String?
  exp : Int?
  nbf : Int?
  iat : Int?
  jti : String?
}
pub fn JwtPayload::default() -> Self

// Type aliases
pub type FC[T] = (T) -> JSXNode

pub type Handler[Env, ExecutionContext] = async (Context[Env, ExecutionContext]) -> @http.Response

pub type Middleware[Env, ExecutionContext] = (Context[Env, ExecutionContext], () -> @core.Promise[@http.Response]) -> @core.Promise[@http.Response]

// Traits
pub trait CssClassName {
  value(Self) -> @core.Any
}
pub impl CssClassName for String

pub trait HonoNode {
  toHonoNode(Self) -> @core.Any
}
pub impl HonoNode for Bool
pub impl HonoNode for Int
pub impl HonoNode for Double
pub impl HonoNode for String
pub impl[T : HonoNode] HonoNode for Array[T]

