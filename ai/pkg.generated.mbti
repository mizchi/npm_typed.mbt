// Generated using `moon info`, DON'T EDIT IT
package "mizchi/npm_typed/ai"

import(
  "mizchi/js/builtins/iterator"
  "mizchi/js/core"
)

// Values
pub fn all_of(Array[StopCondition]) -> StopCondition

pub fn anthropic(String) -> Model

pub fn anthropic_with_options(String, AnthropicOptions) -> Model

pub fn any_of(Array[StopCondition]) -> StopCondition

pub fn convert_array_to_async_iterable(Array[@core.Any]) -> @core.Any

pub fn convert_array_to_readable_stream(Array[@core.Any]) -> @core.Any

pub async fn convert_readable_stream_to_array(@core.Any) -> Array[@core.Any]

#alias(cosine_similarity)
pub fn cosineSimilarity(Array[Double], Array[Double]) -> Double

pub async fn embed(model~ : EmbeddingModel, value~ : String, max_retries? : Int, abort_signal? : @core.Any, headers? : @core.Any) -> EmbedResult

#alias(embed_many)
pub async fn embedMany(model~ : EmbeddingModel, values~ : Array[String], max_parallel_calls? : Int, max_retries? : Int, abort_signal? : @core.Any, headers? : @core.Any) -> EmbedManyResult

pub fn finish_chunk(String, MockUsage) -> @core.Any

#alias(generate_image)
pub async fn generateImage(model~ : ImageModel, prompt~ : String, n? : Int, size? : String, aspectRatio? : String, seed? : Int, providerOptions? : @core.Any, maxRetries? : Int, abortSignal? : @core.Any, headers? : @core.Any) -> GenerateImageResult

#alias(generate_object)
pub async fn generateObject(model~ : Model, schema~ : @core.Any, schema_name? : String, schema_description? : String, output? : OutputStrategy, enum_values? : Array[String], prompt? : String, system? : String, messages? : Array[ModelMessage], max_tokens? : Int, temperature? : Double, max_retries? : Int, abort_signal? : @core.Any) -> GenerateObjectResult

#alias(generate_object_with_zod)
pub async fn generateObjectWithZod(model~ : Model, zod_schema~ : @core.Any, schema_name? : String, schema_description? : String, prompt? : String, system? : String, messages? : Array[ModelMessage], max_tokens? : Int, temperature? : Double) -> GenerateObjectResult

#alias(generate_text)
pub async fn generateText(model~ : Model, messages? : Array[ModelMessage], prompt? : String, system? : String, max_tokens? : Int, temperature? : Double, tools? : Tools, tool_choice? : ToolChoice, max_steps? : Int, stop_when? : StopCondition, prepare_step? : PrepareStep, active_tools? : Array[String]) -> GenerateTextResult

pub fn google(String) -> Model

pub fn google_with_options(String, GoogleOptions) -> Model

pub fn has_any_tool_call(Array[String]) -> StopCondition

pub fn has_tool_call(String) -> StopCondition

pub fn mock_id() -> MockId

pub fn mock_language_model(MockLanguageModelOptions) -> @core.Any

pub fn mock_model_with_stream(Array[@core.Any]) -> @core.Any

pub fn mock_model_with_text(String) -> @core.Any

pub fn mock_values_js(Array[@core.Any]) -> @core.Any

pub fn model_finished() -> StopCondition

pub fn openai(String) -> Model

pub fn openai_with_options(String, OpenAIOptions) -> Model

pub fn require_test() -> @core.Any

pub fn simulate_readable_stream(SimulateStreamOptions) -> @core.Any

pub fn simulate_stream(Array[@core.Any]) -> @core.Any

pub fn simulate_stream_with_delay(Array[@core.Any], Int) -> @core.Any

pub fn step_count_is(Int) -> StopCondition

#alias(stream_text)
pub fn streamText(model~ : Model, messages? : Array[ModelMessage], prompt? : String, system? : String, max_tokens? : Int, temperature? : Double, tools? : Tools, tool_choice? : ToolChoice, max_steps? : Int, stop_when? : StopCondition, prepare_step? : PrepareStep, active_tools? : Array[String]) -> StreamTextResultHandle

pub fn text_delta_chunk(String) -> @core.Any

pub fn tool_call_chunk(String, String, @core.Any) -> @core.Any

// Errors
pub suberror PrepareStep async (PrepareStepContext) -> PrepareStepResult
pub fn PrepareStep::as_any(Self) -> @core.Any

pub suberror StopCondition (StopConditionContext) -> Bool
pub fn StopCondition::as_any(Self) -> @core.Any

// Types and methods
pub(all) struct AnthropicOptions {
  api_key : String?
  base_url : String?
}
pub fn AnthropicOptions::as_any(Self) -> @core.Any
pub fn AnthropicOptions::default() -> Self

#external
pub type AnthropicProvider
pub fn AnthropicProvider::as_any(Self) -> @core.Any
pub fn AnthropicProvider::create(AnthropicOptions) -> Self
pub fn AnthropicProvider::model(Self, String) -> Model
pub fn AnthropicProvider::require() -> Self

pub(all) struct CallWarning {
  type_ : String
  message : String?
  raw : @core.Any
}
pub fn CallWarning::from_any(@core.Any) -> Self

pub(all) enum ContentPart {
  TextPart(text~ : String, provider_metadata~ : ProviderMetadata?)
  ReasoningPart(reasoning~ : ReasoningOutput)
  SourceContentPart(source~ : Source)
  FilePart(file~ : GeneratedFile, provider_metadata~ : ProviderMetadata?)
  ToolCallContentPart(tool_call~ : ToolCall, provider_metadata~ : ProviderMetadata?)
  ToolResultContentPart(tool_result~ : ToolResult, provider_metadata~ : ProviderMetadata?)
  ToolErrorContentPart(tool_error~ : ToolError, provider_metadata~ : ProviderMetadata?)
}
pub fn ContentPart::from_any(@core.Any) -> Self

pub(all) struct EmbedManyResult {
  embeddings : Array[Array[Double]]
  usage : EmbeddingUsage
  raw : @core.Any
}
pub fn EmbedManyResult::from_any(@core.Any) -> Self

pub(all) struct EmbedResult {
  embedding : Array[Double]
  usage : EmbeddingUsage
  raw : @core.Any
}
pub fn EmbedResult::from_any(@core.Any) -> Self

#external
pub type EmbeddingModel
pub fn EmbeddingModel::as_any(Self) -> @core.Any

pub(all) struct EmbeddingUsage {
  tokens : Int
}
pub fn EmbeddingUsage::from_any(@core.Any) -> Self

pub(all) enum FinishReason {
  Stop
  Length
  ContentFilter
  ToolCalls
  Error
  Other
  Unknown
}
pub fn FinishReason::from_string(String) -> Self
pub fn FinishReason::to_string(Self) -> String
pub impl Eq for FinishReason
pub impl Show for FinishReason

pub(all) struct GenerateImageResult {
  image : GeneratedImage
  images : Array[GeneratedImage]
  warnings : Array[CallWarning]
  provider_metadata : ProviderMetadata?
  raw : @core.Any
}
pub fn GenerateImageResult::from_any(@core.Any) -> Self

pub(all) struct GenerateObjectResult {
  object : @core.Any
  finish_reason : FinishReason
  usage : LanguageModelUsage
  warnings : Array[CallWarning]
  response : LanguageModelResponseMetadata
  provider_metadata : ProviderMetadata?
  raw : @core.Any
}
pub fn GenerateObjectResult::from_any(@core.Any) -> Self
pub fn[T] GenerateObjectResult::get_object(Self) -> T

pub(all) struct GenerateTextResult {
  content : Array[ContentPart]
  text : String
  reasoning : Array[ReasoningOutput]
  reasoning_text : String?
  files : Array[GeneratedFile]
  sources : Array[Source]
  tool_calls : Array[ToolCall]
  tool_results : Array[ToolResult]
  finish_reason : FinishReason
  usage : LanguageModelUsage
  total_usage : LanguageModelUsage
  warnings : Array[CallWarning]
  request : LanguageModelRequestMetadata
  response : LanguageModelResponseMetadata
  raw : @core.Any
}
pub fn GenerateTextResult::from_any(@core.Any) -> Self

pub(all) struct GeneratedFile {
  name : String?
  media_type : String?
  data : @core.Any
  raw : @core.Any
}
pub fn GeneratedFile::from_any(@core.Any) -> Self

pub(all) struct GeneratedImage {
  base64 : String
  uint8_array : @core.Any
  raw : @core.Any
}
pub fn GeneratedImage::from_any(@core.Any) -> Self

pub(all) struct GoogleOptions {
  api_key : String?
  base_url : String?
}
pub fn GoogleOptions::as_any(Self) -> @core.Any
pub fn GoogleOptions::default() -> Self

#external
pub type GoogleProvider
pub fn GoogleProvider::as_any(Self) -> @core.Any
pub fn GoogleProvider::create(GoogleOptions) -> Self
pub fn GoogleProvider::model(Self, String) -> Model
pub fn GoogleProvider::require() -> Self

#external
pub type ImageModel
pub fn ImageModel::as_any(Self) -> @core.Any

pub(all) struct LanguageModelRequestMetadata {
  raw : @core.Any
}
pub fn LanguageModelRequestMetadata::from_any(@core.Any) -> Self

pub(all) struct LanguageModelResponseMetadata {
  id : String?
  model_id : String?
  timestamp : @core.Any?
  raw : @core.Any
}
pub fn LanguageModelResponseMetadata::from_any(@core.Any) -> Self

pub(all) struct LanguageModelUsage {
  input_tokens : Int
  output_tokens : Int
  total_tokens : Int
  cached_input_tokens : Int
}
pub fn LanguageModelUsage::from_any(@core.Any) -> Self

pub(all) enum MessageContent {
  Text(String)
  Parts(Array[@core.Any])
}
pub fn MessageContent::as_any(Self) -> @core.Any

pub(all) enum MockContentPart {
  Text(String)
  ToolCall(tool_call_id~ : String, tool_name~ : String, args~ : @core.Any)
}
pub fn MockContentPart::as_any(Self) -> @core.Any

pub(all) enum MockGenerateHandler {
  Result(MockGenerateResult)
  Results(Array[MockGenerateResult])
  Fn(@core.Any)
}

pub(all) struct MockGenerateResult {
  finish_reason : String
  usage : MockUsage
  content : Array[MockContentPart]
  warnings : Array[@core.Any]
}
pub fn MockGenerateResult::as_any(Self) -> @core.Any

pub(all) struct MockId {
  mut counter : Int
}
pub fn MockId::new() -> Self
pub fn MockId::next(Self) -> Int
pub fn MockId::next_string(Self) -> String
pub fn MockId::reset(Self) -> Unit

pub(all) struct MockLanguageModelOptions {
  provider : String?
  model_id : String?
  do_generate : MockGenerateHandler?
  do_stream : MockStreamHandler?
}

pub(all) enum MockStreamHandler {
  Result(MockStreamResult)
  Results(Array[MockStreamResult])
  Fn(@core.Any)
}

pub(all) struct MockStreamResult {
  stream : @core.Any
}
pub fn MockStreamResult::as_any(Self) -> @core.Any

pub(all) struct MockUsage {
  input_tokens : Int
  output_tokens : Int
  total_tokens : Int
}

pub(all) struct MockValues[T] {
  values : Array[T]
  mut counter : Int
}
pub fn[T] MockValues::new(Array[T]) -> Self[T]
pub fn[T] MockValues::next(Self[T]) -> T
pub fn[T] MockValues::reset(Self[T]) -> Unit

#external
pub type Model
pub fn Model::as_any(Self) -> @core.Any

pub(all) enum ModelMessage {
  UserMessage(content~ : MessageContent)
  AssistantMessage(content~ : MessageContent)
  SystemMessage(content~ : MessageContent)
  ToolMessage(content~ : MessageContent)
}
pub fn ModelMessage::as_any(Self) -> @core.Any

pub(all) struct OpenAIOptions {
  api_key : String?
  base_url : String?
  organization : String?
}
pub fn OpenAIOptions::as_any(Self) -> @core.Any
pub fn OpenAIOptions::default() -> Self

#external
pub type OpenAIProvider
pub fn OpenAIProvider::as_any(Self) -> @core.Any
pub fn OpenAIProvider::create(OpenAIOptions) -> Self
pub fn OpenAIProvider::model(Self, String) -> Model
pub fn OpenAIProvider::require() -> Self

pub(all) enum OutputStrategy {
  Object
  Array
  Enum
  NoSchema
}
pub fn OutputStrategy::to_string(Self) -> String

pub(all) struct PrepareStepContext {
  step_number : Int
  messages : Array[@core.Any]
  steps : Array[StepResult]
}

pub(all) struct PrepareStepResult {
  model : Model?
  activeTools : Array[String]?
  messages : Array[@core.Any]?
  system : String?
  maxTokens : Int?
  temperature : Double?
}
pub fn PrepareStepResult::as_any(Self) -> @core.Any
pub fn PrepareStepResult::empty() -> Self
pub fn PrepareStepResult::with_active_tools(Array[String]) -> Self
pub fn PrepareStepResult::with_messages(Array[@core.Any]) -> Self
pub fn PrepareStepResult::with_model(Model) -> Self

pub(all) struct ProviderMetadata {
  raw : @core.Any
}
pub fn ProviderMetadata::as_any(Self) -> @core.Any
pub fn ProviderMetadata::from_any(@core.Any) -> Self?

pub(all) struct ReasoningOutput {
  text : String
  provider_metadata : ProviderMetadata?
}
pub fn ReasoningOutput::from_any(@core.Any) -> Self

pub(all) struct SimulateStreamOptions {
  chunks : Array[@core.Any]
  initial_delay_ms : Int?
  chunk_delay_ms : Int?
}

pub(all) enum Source {
  UrlSource(SourceUrl)
  DocumentSource(SourceDocument)
}
pub fn Source::from_any(@core.Any) -> Self

pub(all) struct SourceDocument {
  id : String
  title : String?
  provider_metadata : ProviderMetadata?
}

pub(all) enum SourceType {
  Url
  Document
}
pub fn SourceType::from_string(String) -> Self
pub impl Eq for SourceType
pub impl Show for SourceType

pub(all) struct SourceUrl {
  id : String
  url : String
  title : String?
  provider_metadata : ProviderMetadata?
}

pub(all) struct StepResult {
  content : Array[ContentPart]
  text : String
  reasoning : Array[ReasoningOutput]
  finish_reason : FinishReason
  usage : LanguageModelUsage
  warnings : Array[CallWarning]
  response : LanguageModelResponseMetadata
  raw : @core.Any
}
pub fn StepResult::from_any(@core.Any) -> Self

pub(all) struct StopConditionContext {
  step_number : Int
  messages : Array[@core.Any]
  tool_calls : Array[ToolCall]
  finish_reason : FinishReason
}

#external
pub type StreamTextResultHandle
pub fn StreamTextResultHandle::as_any(Self) -> @core.Any
#alias(finish_reason)
pub async fn StreamTextResultHandle::finishReason(Self) -> FinishReason
#alias(full_stream)
pub fn StreamTextResultHandle::fullStream(Self) -> TextStreamPartIterator
#alias(full_stream_raw)
pub fn StreamTextResultHandle::fullStreamRaw(Self) -> @iterator.AsyncIterator[@core.Any]
pub async fn StreamTextResultHandle::steps(Self) -> Array[StepResult]
pub async fn StreamTextResultHandle::text(Self) -> String
#alias(text_stream)
pub fn StreamTextResultHandle::textStream(Self) -> @iterator.AsyncIterator[String]
pub async fn StreamTextResultHandle::usage(Self) -> LanguageModelUsage

pub(all) enum TextStreamPart {
  TextStart(id~ : String, provider_metadata~ : ProviderMetadata?)
  TextEnd(id~ : String, provider_metadata~ : ProviderMetadata?)
  TextDelta(id~ : String, text~ : String, provider_metadata~ : ProviderMetadata?)
  ReasoningStart(id~ : String, provider_metadata~ : ProviderMetadata?)
  ReasoningEnd(id~ : String, provider_metadata~ : ProviderMetadata?)
  ReasoningDelta(id~ : String, text~ : String, provider_metadata~ : ProviderMetadata?)
  ToolInputStart(id~ : String, tool_name~ : String, provider_metadata~ : ProviderMetadata?, provider_executed~ : Bool?, dynamic~ : Bool?, title~ : String?)
  ToolInputEnd(id~ : String, provider_metadata~ : ProviderMetadata?)
  ToolInputDelta(id~ : String, delta~ : String, provider_metadata~ : ProviderMetadata?)
  SourcePart(source~ : Source)
  FilePart(file~ : GeneratedFile)
  ToolCallPart(tool_call~ : ToolCall)
  ToolResultPart(tool_result~ : ToolResult)
  ToolErrorPart(tool_error~ : ToolError)
  ToolOutputDeniedPart(tool_output_denied~ : ToolOutputDenied)
  ToolApprovalRequestPart(tool_approval_request~ : ToolApprovalRequest)
  StartStep(request~ : LanguageModelRequestMetadata, warnings~ : Array[CallWarning])
  FinishStep(response~ : LanguageModelResponseMetadata, usage~ : LanguageModelUsage, finish_reason~ : FinishReason, provider_metadata~ : ProviderMetadata?)
  Start
  Finish(finish_reason~ : FinishReason, total_usage~ : LanguageModelUsage)
  Abort
  Error(error~ : @core.Any)
  Raw(raw_value~ : @core.Any)
  Unknown(type_~ : String, raw~ : @core.Any)
}
pub fn TextStreamPart::from_any(@core.Any) -> Self
pub fn TextStreamPart::get_reasoning_text(Self) -> String?
pub fn TextStreamPart::get_text(Self) -> String?
pub fn TextStreamPart::is_reasoning_part(Self) -> Bool
pub fn TextStreamPart::is_text_part(Self) -> Bool
pub fn TextStreamPart::is_tool_part(Self) -> Bool
pub fn TextStreamPart::type_string(Self) -> String

pub(all) struct TextStreamPartIterator {
  raw : @iterator.AsyncIterator[@core.Any]
}
pub async fn TextStreamPartIterator::next(Self) -> TextStreamPart?

pub(all) struct Tool {
  description : String
  input_schema : @core.Any
  execute : (@core.Any) -> @core.Any
}
pub fn Tool::as_any(Self) -> @core.Any
pub fn[Input, Output : ToJson] Tool::typed(description~ : String, input_schema~ : Json, (Input) -> Output) -> Self
pub fn[Input, Output : ToJson] Tool::typed_async(description~ : String, input_schema~ : Json, async (Input) -> Output) -> Self

pub(all) struct ToolApprovalRequest {
  tool_call_id : String
  tool_name : String
  input : @core.Any
}
pub fn ToolApprovalRequest::from_any(@core.Any) -> Self

pub(all) struct ToolCall {
  tool_call_id : String
  tool_name : String
  input : @core.Any
}
pub fn ToolCall::from_any(@core.Any) -> Self

pub(all) enum ToolChoice {
  Auto
  Required
  None_
  Tool(String)
}
pub fn ToolChoice::as_any(Self) -> @core.Any

pub(all) struct ToolError {
  tool_call_id : String
  tool_name : String
  args : @core.Any
  error : @core.Any
}
pub fn ToolError::from_any(@core.Any) -> Self

pub(all) struct ToolOutputDenied {
  tool_call_id : String
  tool_name : String
  input : @core.Any
}
pub fn ToolOutputDenied::from_any(@core.Any) -> Self

pub(all) struct ToolResult {
  tool_call_id : String
  tool_name : String
  input : @core.Any
  output : @core.Any
}
pub fn ToolResult::from_any(@core.Any) -> Self

pub(all) struct Tools {
  tools : Map[String, Tool]
}
pub fn Tools::add(Self, String, Tool) -> Self
pub fn Tools::as_any(Self) -> @core.Any
pub fn Tools::new() -> Self

// Type aliases

// Traits

